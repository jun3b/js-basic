<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <title>JS study</title>
  </head>
  <body>
    <script>
      // 링크드 리스트 만들기
      class Node {
        constructor(val) {
          this.val = val;
          this.next = null;
          // 처음에는 다음 노드가 없기 때문에 this.next = null;
        }
      }

      class SinglyLinkedList {
        constructor(){
          this.head = null;
          this.tail = null;
          this.length = 0;
        }

        // 1. push 메소드 구현하기 -> 새로운 노드를 맨 마지막에 삽입
        push(val) {
          var newNode = new Node(val);
          // 비어있는 리스트에 처음 노드를 삽입하면 헤드와 테일이 모두 그 첫번째 노드를 가리킴
          if(!this.head) {
            this.head = newNode;
            this.tail = this.head;
          } else {
          // 기존의 리스트에 새로운 노드를 삽입하면 맨 마지막의 tail에 새로운 노드를 삽입하고 tail이 이동함 
            this.tail.next = newNode;
            this.tail = newNode;
          }
          this.length++;
          return this;
        }

        // 2. pop 메소드 구현하기 -> 링크드 리스트의 맨 마지막 노드 제거
        pop() {
          // 리스트에 노드가 없을 경우 undefined 반환
          if(!this.head) return undefined;
          // 마지막 노드를 제거하기 위해서는 첫번째 노드부터 마지막 노드까지 이동해야함
          var current = this.head;
          var newTail = current;
          while(current.next) {
            // 리스트에 무언가가 남겨져 있는 한 while로 계속 반복
            newTail = current;
            current = current.next;
          }
          // console.log(current.val);
          // console.log(newTail.val);
          // 마지막 노드 이전의 노드가 tail 이 되고 기존의 마지막 노드는 null
          this.tail = newTail;
          this.tail.next = null;
          this.length--;
          // 리스트에 있는 노드를 전부 삭제했으면 리스트가 비어있어야 함
          if(this.length === 0) {
            this.head = null;
            this.tail = null;
          }
          return current;
        }

        // 3. shift 메소드 구현하기 -> 맨 앞의 헤드 노드를 제거하고 그 다음 노드가 헤드가 됨
        shift() {
          if(!this.head) return undefined;

          var currentHead = this.head;
          this.head = currentHead.next;
          this.length--;

          if(this.length == 0) {
            this.tail = null;
          }
          return currentHead;
        }

        // 4. unshift 메소드 구현하기 -> 새로운 노드를 리스트에 추가
        // push 와는 다르게 리스트 맨 앞에 노드를 추가
        unshift(val) {
          var newNode = new Node(val);
          // 리스트에 아무 데이터도 없는 경우
          if(!this.head) {
            this.head = newNode;
            this.tail = this.head;
          } else {
            // 헤드를 newNode 다음 노드로 옮겼다가 다시 newNode로 옮김
            // * -> HELLO -> GOODBYE -> !
            //       head
            // head
            newNode.next = this.head;
            this.head = newNode;
            // 리스트는 배열과 달리 index가 없으므로 길이만 늘려주면 됨
            this.length++;
            // 위의 로직이 else{} 안에 있는게 아닐 경우 !this.head 인 상태에서 shift 로 값 넣었을 때 newNode.next 에 newNode(자기자신)을 지정함
          }
          return this;
        }

        // 5. get 메소드 구현하기 -> 인덱스 혹은 위치를 의미하는 숫자를 인자로 받아서 해당 노드를 return
        // 리스트는 인덱스가 없으므로 맨 처음 노드부터 시작하여 next로 이동해야 함
        get(index) {
          if(index < 0 || index >= this.length) return null;
          var counter = 0;
          var current = this.head;
          while(counter !== index) {
            current = current.next;
            counter++;
          }
          return current;
        }

        // 6. set 메소드 구현하기 -> 원하는 index 의 노드의 값을 원하는 값으로 변경함
        set(index, val) {
          // get 메소드로 index 에 해당하는 node 값을 가져옴
          var foundNode = this.get(index);
          if(foundNode) {
            foundNode.val = val;
            return true;
          }
          return false;
        }

        // 7. insert 메소드 구현하기 -> index와 val을 받아서 val을 update(변경)하는게 아니라 해당 위치에 삽입함
        insert(index, val) {
          if(index < 0 || index > this.length) return false;
          if(index === this.length) return !!this.push(val);
          if(index === 0) return !!this.unshift(val);
          // push 와 unshift 모두 return this; 로 list 전체를 반환함 -> true/false로 return 하고 싶을 경우
          // ! 연산자 사용 => !은 boolean 값을 return 하기 때문에 !this.push(val) 하면 원래 값의 반대 값을 return
          // !! 연산자를 사용하면 부정의 부정 = 참 / 참의 부정 = 부정을 반환할 것 
          // index === 0 이면 true 반환, index === this.length 면 true 반환

          // 바로 이전 노드를 찾아서 이전노드.next 에 val을 insert 해야 함
          var newNode = new Node(val);
          var prev = this.get(index-1);
          // temp 에 임시로 값을 저장해둠
          var temp = prev.next;
          prev.next = newNode;
          newNode.next = temp;
          this.length++;
          return true;
        }
      }
      
      var list = new SinglyLinkedList();
      list.push("Hello");
      list.push("Goodbye");
      list.push("!");
      list.push("<3");
      list.push(":)");

    </script>
    </div>
  </body>
</html>
